"""
Functions to measure accuracy, error metrics, and plot comparisons of generated spline data 
based on original points extracted from OpenDRIVE files.

:param original_points: Original road geometry points extracted from an OpenDRIVE file.
:param spline_points: Points generated by fitting a spline curve to the original road geometry.
:return: Functions for measuring accuracy, maximum error, R-squared value, RMSE, and plotting comparisons.
"""

import csv
import os
import numpy as np
import matplotlib.pyplot as plt
import sys
import logging
from sklearn.metrics import r2_score
from datetime import datetime
timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

# Append the project directory to the path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from opendrive2catmull.opendrive_converter import get_road_geometry, generate_spline

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def measure_spline_accuracy(original_points, spline_points):
    """
    Measure the accuracy of the generated spline compared to the original points.
    """
    original_points = np.array(original_points)
    spline_points = np.array(spline_points)

    # Generate parameter t for interpolation
    t_original = np.linspace(0, 1, len(original_points))
    t_spline = np.linspace(0, 1, len(spline_points))

    # Interpolate spline points onto t_original
    spline_interp_x = np.interp(t_original, t_spline, spline_points[:, 0])
    spline_interp_y = np.interp(t_original, t_spline, spline_points[:, 1])
    spline_interp_z = np.interp(t_original, t_spline, spline_points[:, 2])

    # Combine interpolated coordinates into a single array
    spline_interp = np.column_stack((spline_interp_x, spline_interp_y, spline_interp_z))

    # Compute distances between original points and interpolated spline points
    distances = np.linalg.norm(original_points[:, :3] - spline_interp, axis=1)
    average_distance = np.mean(distances)

    # Calculate the maximum possible error based on the bounding box of original points
    bounding_box = original_points[:, :3]
    max_possible_error = np.linalg.norm(bounding_box.min(axis=0) - bounding_box.max(axis=0))

    # Calculate accuracy percentage
    accuracy_percentage = (1 - (average_distance / max_possible_error)) * 100
    return accuracy_percentage


def calculate_r_squared(original_points, spline_points):
    """
    Calculate the R-squared value of the spline compared to the original points.
    """
    original_points = np.array(original_points)
    spline_points = np.array(spline_points)

    # Generate parameter t for interpolation
    t_original = np.linspace(0, 1, len(original_points))
    t_spline = np.linspace(0, 1, len(spline_points))

    # Interpolate spline points onto t_original
    spline_interp_x = np.interp(t_original, t_spline, spline_points[:, 0])
    spline_interp_y = np.interp(t_original, t_spline, spline_points[:, 1])

    # Combine interpolated coordinates into a single array
    spline_interp = np.column_stack((spline_interp_x, spline_interp_y))

    # Calculate R-squared value
    r2 = r2_score(original_points[:, :2], spline_interp)
    return r2


def plot_comparison(original_points, spline_points, road_name):
    """
    Plot and compare original road points and generated spline points.
    """
    original_points = np.array(original_points)
    spline_points = np.array(spline_points)
    fig, axes = plt.subplots(1, 2, figsize=(10, 5))

    # Plot original points
    axes[0].scatter(original_points[:, 0], original_points[:, 1], s=5, color='skyblue', label='Original Points')
    axes[0].set_title(f'Original Points - {road_name}')
    axes[0].set_xlabel('X')
    axes[0].set_ylabel('Y')
    axes[0].legend()
    axes[0].grid(True)

    # Plot spline points
    axes[1].plot(spline_points[:, 0], spline_points[:, 1], '-', label='Generated Spline', color='green')
    axes[1].set_title(f'Generated Spline - {road_name}')
    axes[1].set_xlabel('X')
    axes[1].set_ylabel('Y')
    axes[1].legend()
    axes[1].grid(True)

    plt.tight_layout()
    return fig


if __name__ == "__main__":
    # Define the directory containing OpenDRIVE files
    opendrive_dir = '/Users/ali/Documents/GitHub/udacity-test-generation/SensoDat/Opendrive_Files/campaign_2_frenetic'
    opendrive_files = [os.path.join(opendrive_dir, f"{i}.xodr") for i in range(1000)]
    opendrive_files = [f for f in opendrive_files if os.path.exists(f)]

    if not opendrive_files:
        logger.error("No OpenDRIVE files found to process.")
        sys.exit()

    # Output directory for results
    output_dir = './output'
    os.makedirs(output_dir, exist_ok=True)

    results = []
    total_accuracy = 0
    total_r_squared = 0

    for idx, opendrive_file in enumerate(opendrive_files):
        # logger.info(f"Processing file: {opendrive_file}")
        original_points = get_road_geometry(opendrive_file)
        original_points = original_points[1:-2]  # Skip the first point and last 2 points for better comparison as catmull rom spline does not inlude these points for generating spline

        control_points, spline_points = generate_spline(opendrive_file)

        if len(original_points) < 4 or len(spline_points) < 4:
            logger.warning(f"Not enough points for spline generation in file {opendrive_file}. Skipping.")
            continue

        accuracy = measure_spline_accuracy(original_points, spline_points)
        r_squared = calculate_r_squared(original_points, spline_points)

        total_accuracy += accuracy
        total_r_squared += r_squared

        results.append([f"Road {idx}", accuracy, r_squared])

    # Calculate averages
    num_files = len(results)
    avg_accuracy = total_accuracy / num_files if num_files else 0
    avg_r_squared = total_r_squared / num_files if num_files else 0

    # Save results to CSV
    output_csv = os.path.join(output_dir, f"spline_results_{timestamp}.csv")
    with open(output_csv, mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(["Road Name", "Accuracy (%)", "R-squared"])
        writer.writerows(results)
        writer.writerow(["Average", avg_accuracy, avg_r_squared])

    logger.info(f"Results saved to {output_csv}")
    print(f"Average Accuracy: {avg_accuracy:.2f}%")
    print(f"Average R-squared: {avg_r_squared:.6f}")
